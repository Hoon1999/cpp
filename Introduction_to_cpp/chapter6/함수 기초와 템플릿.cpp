#include <iostream>

using namespace std;

inline float square(float x) { return x * x; }
int 월급(int 근무시간, int 시급 = 9620);
int main() {
	/*
	1. inline function
	2. default parameter
	3. reference 변수
	4. 함수 overloading
	5. 함수 templete
	*/
	//인라인 함수란?
	//함수의 코드 부분을 프로그램에 삽입하는 것.
	//일반적인 함수랑 뭐가 다른거지?
	//함수는 원래 주소값을 가지고 호출하는 형태로 사용된다.
	//함수를 호출하면 해당 주소값으로 가서 코드를 실행하고 돌아오는 과정을 거친다.
	//일반적으로 호출로 발생하는 시간은 영향력이 적다.
	//만약 매우 짧은 코드의 함수를 매우 자주 호출하게 되면, 프로그램의 실행시간이 길어지게 된다.
	
	//여태까지 컴파일하면 함수가 코드 부분에 삽입된다고 잘못 알고 있었다.(이건 인라인함수 개념)
	//inline 키워드를 함수의 선언 앞에 붙여주면 된다.
	//인라인 함수의 경우는 코드가 매우 짧으므로 일반적으로 정의까지 한다.
	//함수의 사용 방법은 동일하다. 
	float a = 1.2;
	cout << "1.2^2 = " << square(a) << endl;
	
	// 디폴트 매개변수란?
	// 매개변수 값을 생략시 미리 정해놓은 값이 입력되는 변수
	// 엑셀 함수나 winform 컨트롤에서 많이 봤던것이다.
	
	//함수 선언부분의 매개변수에 값을 초기화 해주면 디폴트 매개변수가 된다.
	//당연하게도 디폴트 매개변수는 뒤에서부터 할당(?)이 가능하다.
	cout << 월급(3) << endl;

	//참조변수란?
	//원래변수(참조 당하는 변수)에 직접 접근할 수 있는 변수이다.
	//포인터와의 차이점?
	//포인터는 간접참조이고, 참조변수는 직접참조이다.
	//포인터에 접근하고, 포인터에서 다시 변수로 접근하니까 간접참조.
	//참조변수는 원래 변수에 이름을 하나 더 붙인거라고 보면된다.
	//함수의 매개변수로 포인터 대신 참조변수를 주면 같은 역할을 수행하면서 참조연산자(*)없이 사용가능하다.

	//참조변수의 선언
	int b = 10;
	int& ref_b = b;
	ref_b = 15; //포인터였다면 참조연산자 *을 붙여줘야 하지만 ref_b 자체가 b의 별칭이기 때문에 그럴필요가 없다.
	cout << "b = " << b << endl;

	//함수 오버로딩은 자바 메소드 오버로딩과 완벽하게 같음.

	//함수 템플릿이란?
	//자료형에 제약받지 않고 포괄적으로 사용할 수 있는 함수. 따라서 템플릿이라고 칭한다.
	//이를 일반화라고 하며 일반화를 사용한 프로그래밍을 일반화 프로그래밍이라고 함.

	//함수 템플릿의 선언과 사용
	//선언이나 정의 부분 앞에 templete <typename T>
	//선언 부분의 자료형에는 T 를 넣어준다. 당연히 T는 임의의 이름이다.
	/*
	* templete <typename Any>
	* Any sum(Any a, Any b) {return a + b;}
	* 
	* main(){
		int a = 10, b = 20;
		sum(a, b); 
		// Any에 자료형이 int 하나가 고정된 순간 모든 Any들이 int로 고정된다. 
		//그래서 a 는 int, b는 float 이런 방식으로 사용이 불가능하다.
	  }
	*/
	
	//일반화 프로그래밍 c# 에서 했던 기억이 있어서 찾아보니 작성방법이 약간 다르네
	return 0;
}
int 월급(int 근무시간, int 시급) {

	return 근무시간 * 시급;
}